# Quality check on Unicorn RNASeq data             (What)

* Aug 23, 2025                                     (When)
* biotrainee ~/1000_noncoding/3.SV_analysis/2.analysis           (Where)
*                                                   (Why)
I want to make sure that the quality of my reads obtained from the Illumina Novaseq look good before proceeding.


## 代码                                          (How)

```
##
library(doParallel)


##loading files
load("~/1000_noncoding/3.SV_analysis/2.analysis/5-1_df_cancergene_svcluster.Rdata")
load("~/1000_noncoding/3.SV_analysis/2.analysis/expr_all.Rdata")
expr <- expr_allsamples
load("~/1000_noncoding/3.SV_analysis/2.analysis/config_986.Rdata")
load("~/1000_noncoding/3.SV_analysis/2.analysis/genes_expr_less50Tumor.Rdata")
if(1){
  cnv_filepath <- "/home/data/t190513/1000_noncoding/3.SV_analysis/1.resources/all_data_by_genes.txt"
  cnv <- fread(cnv_filepath,data.table = F)
  cnv_1 <- cnv
  rownames(cnv_1) <- cnv_1$`Gene Symbol`
  cnv_1[,1:3] <- NULL
  #只留下config有的样本Tumor的列
  pattern <- paste(config_986,collapse = "|")
  cnv_1 <- cnv_1[,grepl(pattern,colnames(cnv_1))]
}

##计算差异表达p值
#计算raw_foldchange,raw_p,cnnormal_foldchange,cnnormal_p
expr_rownames <- rownames(expr)
expr_hugosymbol <- sapply(expr_rownames,function(x) strsplit(x,"\\|")[[1]][2])
#Func1 输入gene和df,返回raw_p和raw_foldchange
p_expr <- function(chr,start,end,gene,df,expr_rownames,expr_hugosymbol){
  library(dplyr)
  mutated_samples <- df %>%
    filter(gene_name==gene,chr_merge==chr,start_merge==start,end_merge==end) %>%
    select(SAMPLE)
  mutated_samples <- unique(mutated_samples$SAMPLE)
  mutated_indices <- which(names(expr) %in% mutated_samples)
  d_f <- data.frame()
  #如果该基因是ENSG开头,与在rownames里即可
  if(grepl("^ENSG",gene)){
    d_f <- expr[grepl(gene,expr_rownames),]
  }else{ #如果是Hugo_Symbol与Hugo_Symbol比对，需完全匹配
    d_f <- expr[expr_hugosymbol==gene,]
  }
  #如果能匹配上
  if(nrow(d_f)==1 & sum(mutated_indices) != 0){
    # 将表达量分组
    #原本的mutated samples是以，相连接的一些值，弄成一个向量
    group_mutated <- as.numeric(d_f[1,mutated_indices])
    group_unmutated <- as.numeric(d_f[1,-mutated_indices])
    #进行检验
    wilcox_test_result <- wilcox.test(group_mutated, group_unmutated)
    p <- wilcox_test_result$p.value
    #结果写入result
    log2_fc <- log2(median(as.numeric(group_mutated))/median(as.numeric(group_unmutated)))
    result <- paste(p,log2_fc,sep = ":")
    return(result)
  }else{return(NA)
  }
}
#Func2 输入id，靶基因，和ems数据框，得到突变样本和非突变样本的值和检验p值和log2 FC,和Func1不同的是
#假设检验仅在cn normal的样本中进行(1-22 cn=2)
p_expr_cnnormal <- function(chr,start,end,target_gene,df,expr_rownames,expr_hugosymbol){
  library(dplyr)
  mutated_samples <- df %>%
    filter(gene_name==target_gene,chr_merge==chr,start_merge==start,end_merge==end) %>%
    select(SAMPLE)
  mutated_samples <- unique(mutated_samples$SAMPLE)
  cn_samples <- names(cnv_1)[cnv_1[target_gene, ] > log2(1/2) & cnv_1[target_gene, ] < log2(2)]
  #cn_samples <- names(cnv_1)[cnv_1[target_gene, ] %in% c(-1,0,1)]
  cn_mutated_samples <- intersect(cn_samples,mutated_samples)
  cn_unmutated_samples <- setdiff(cn_samples,mutated_samples)
  mutated_indices <- which(names(expr) %in% cn_mutated_samples)
  unmutated_indices <- which(names(expr) %in% cn_unmutated_samples)
  d_f <- data.frame()
  #如果该基因是ENSG开头,与在rownames里即可
  if(grepl("^ENSG",target_gene)){
    d_f <- expr[grepl(target_gene,expr_rownames),]
  }else{ #如果是Hugo_Symbol与Hugo_Symbol比对，需完全匹配
    d_f <- expr[expr_hugosymbol==target_gene,]
  }
  #如果能匹配上且samples不为0
  if(nrow(d_f)==1 & sum(mutated_indices) != 0){
    # 将表达量分组
    #原本的mutated samples是以，相连接的一些值，弄成一个向量
    group_mutated <- as.numeric(d_f[1,mutated_indices])
    group_unmutated <- as.numeric(d_f[1,unmutated_indices])
    #进行检验
    wilcox_test_result <- wilcox.test(group_mutated, group_unmutated)
    p <- wilcox_test_result$p.value
    #结果写入result
    log2_fc <- log2(median(as.numeric(group_mutated))/median(as.numeric(group_unmutated)))
    result <- paste(p,log2_fc,sep = ":")
    return(result)
  }else{return(NA)
  }
}

df <- df_cancergene_svcluster[,c(1:3,23,24,28)]
df <- unique(df) #一共是2515个cancer gene-related cluster

#计算raw_p和raw_fc
if(1){
  results <- rep(NA,nrow(df))
  cl <- makeCluster(48)
  # 注册并行后端
  registerDoParallel(cl)
  # 并行执行 for 循环
  results <- foreach(i = 1:nrow(df), .combine = c) %dopar% {
    library(dplyr)
    p_expr(df$chr_merge[i],df$start_merge[i],df$end_merge[i],
           df$gene_name[i],df_cancergene_svcluster[,-c(25,26,27)], expr_rownames, expr_hugosymbol)
  }
  # 停止并行计算
  stopCluster(cl)
  df$p_expr <- results
  df <- df %>%
    separate(p_expr,into=c("raw_expr_p","raw_expr_log2FC"),sep = ":")
}
#计算cnnormal_p和cnnormal_fc
if(1){
  results <- rep(NA,nrow(df))
  cl <- makeCluster(48)
  # 注册并行后端
  registerDoParallel(cl)
  # 并行执行 for 循环
  results <- foreach(i = 1:nrow(df), .combine = c) %dopar% {
    library(dplyr)
    p_expr_cnnormal(df$chr_merge[i],df$start_merge[i],df$end_merge[i],
                    df$gene_name[i],df_cancergene_svcluster[,-c(25,26,27)], expr_rownames, expr_hugosymbol)
  }
  # 停止并行计算
  stopCluster(cl)
  df$p_expr_cnnormal <- results
  df <- df %>%
    separate(p_expr_cnnormal,into=c("cnnormal_expr_p","cnnormal_expr_log2FC"),sep = ":")
}

df <- df %>%
  mutate(expr_over_50=ifelse(gene_name %in% gene_expr_less50,TRUE,FALSE)) %>% #其实gene_expr_less50是over50的基因集，变量名写反了不过不影响
  mutate(cancer_gene=ifelse(gene_name %in% all_drivergenes_list,TRUE,FALSE))
df_svcluster_expr <- df

save(df_svcluster_expr,file="~/1000_noncoding/3.SV_analysis/2.analysis/5-2.df_svcluster_expr.Rdata")





```
                                                    (Result)
The output from FASTQC and multiqc look good!  Proceeding to differential expression analysis of unicorn horn between activated and unactivated samples.
