# 写了一个叫SRJ的算法来寻找高频的通过sv被重排到一起的fusion-like事件，先用ALK来验证下算法的可靠性     (What)

* Aug 23, 2025                                     (When)
* biotrainee ~/1000_noncoding/3.SV_analysis/2.analysis           (Where)
*                                                   (Why)

## 代码                                          (How)

```
##loading packages
library(GenomicRanges)
library(dplyr)
library(parallel)
library(patchwork)
library(tidyverse)
library(data.table)
library(doParallel)
library(ggthemes)
library(ggsci)


##loading files
#需要SV的bedpe文件
load("~/1000_noncoding/3.SV_analysis/2.analysis/bedpe_986.Rdata") #bedpe_986
#需要基因的bed文件
load("~/1000_noncoding/3.SV_analysis/2.analysis/ensembl_canonical_transcripts_bed4.Rdata")
load("~/1000_noncoding/3.SV_analysis/2.analysis/3-3v3.all_drivergenes_list.Rdata")


#目标数据框1
#gene gene区间  pos1 pos2
gr_bedpes <- GRanges(
  seqnames = bedpe_986$CHROM_A,
  ranges = IRanges(start = bedpe_986$START_A+1,end = bedpe_986$END_A)
)
gr_genes <- GRanges(
  seqnames = ensembl_canonical_transcripts_bed4$chr,
  ranges = IRanges(start = ensembl_canonical_transcripts_bed4$start+1,end = ensembl_canonical_transcripts_bed4$end)
)

hits_gene_bedpes <- findOverlaps(gr_genes,gr_bedpes)
overlap_data <- data.frame(
  gene_index = queryHits(hits_gene_bedpes),
  bedpe_index = subjectHits(hits_gene_bedpes)
)
result <- cbind(ensembl_canonical_transcripts_bed4[overlap_data$gene_index, ],bedpe_986[overlap_data$bedpe_index, ])
rheinbay_test_table1 <- result
save(rheinbay_test_table1,file="~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_table1.Rdata")

#目标数据框2
#gene 重排patner反复出现的区间 反复出现的次数
load("~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_table1.Rdata")
load("~/1000_noncoding/3.SV_analysis/2.analysis/ensembl_canonical_transcripts_bed4.Rdata")

#函数，输入基因得到相应数据
get_merge_candidate <- function(gene){
  library(GenomicRanges)
  library(dplyr)
  df <- rheinbay_test_table1[rheinbay_test_table1$gene_name==gene,]
  #得到所有的候选1Mb区间
  if(1){
    # 创建一个空的数据框来存储新的区间
    candidate_hotspot_region <- data.frame(chr = character(), start = numeric(), end = numeric(), gene_name = character(), stringsAsFactors = FALSE)
    row_index <- 1
    start <- df$START_B
    end <- df$END_B
    chr <- df$CHROM_B
    gene_name <- df$gene_name
    upstream_start <- rep(NA,nrow(df))
    upstream_end <- rep(NA,nrow(df))
    downstream_start <- rep(NA,nrow(df))
    downstream_end <- rep(NA,nrow(df))

    if(nrow(df)>0){
      for (i in 1:nrow(df)) {

        # 上游1Mb
        upstream_start[i] <- start[i] - 1000000
        upstream_end[i] <- start[i]+1
        if (upstream_start[i] < 0) upstream_start[i] <- 0  # 防止负值

        # 下游1Mb
        downstream_start[i] <- end[i]-1
        downstream_end[i] <- end[i] + 1000000

      }
      candidate_hotspot_region_upstream <- data.frame(chr,start=upstream_start,end=upstream_end,gene_name)
      candidate_hotspot_region_downstream <- data.frame(chr,start=downstream_start,end=downstream_end,gene_name)
      candidate_hotspot_region <- rbind(candidate_hotspot_region_upstream,candidate_hotspot_region_downstream) %>%
        arrange(chr,start,gene_name)

      #与patner overlap得到overlap样本数>=2的区间，以及n
      gr_candidate_hotspot_region <- GRanges(
        seqnames = candidate_hotspot_region$chr,
        ranges = IRanges(start = candidate_hotspot_region$start+1, end = candidate_hotspot_region$end)
      )
      gr_patners <- GRanges(
        seqnames = df$CHROM_B,
        ranges = IRanges(start = df$START_B+1,end = df$END_B)
      )
      hits_chr_patners <- findOverlaps(gr_candidate_hotspot_region,gr_patners)
      overlap_data <- data.frame(
        chr_index = queryHits(hits_chr_patners),
        partner_index = subjectHits(hits_chr_patners)
      )
      result <- cbind(candidate_hotspot_region[overlap_data$chr_index, ],
                      df[overlap_data$partner_index,-c(1,2,3) ])
      colnames(result)[1:3] <- c("chr_candidate","start_candidate","end_candidate")
      result <- result[,-c(5)]
      result <- result%>%
        group_by(chr_candidate,start_candidate,end_candidate) %>%
        mutate(distinct_samples = n_distinct(SAMPLE)) %>%
        ungroup() %>%
        filter(distinct_samples>1)
      #把重叠的candidate区间合并起来
      gr_merge <- GRanges(seqnames = result$chr_candidate,
                          ranges = IRanges(start = result$start_candidate,
                                           end = result$end_candidate))
      gr_merge <- GenomicRanges::reduce(gr_merge)
      gr_patners <- GRanges(
        seqnames = df$CHROM_B,
        ranges = IRanges(start = df$START_B+1,end = df$END_B)
      )
      hits_merge_patners <- findOverlaps(gr_merge,gr_patners)
      overlap_data <- data.frame(
        merge_index = queryHits(hits_merge_patners),
        partner_index = subjectHits(hits_merge_patners)
      )
      merge_hotspot_region=data.frame(chr_merge=gr_merge@seqnames,start_merge=gr_merge@ranges)
      result1 <- cbind(merge_hotspot_region[overlap_data$merge_index, ],
                       df[overlap_data$partner_index,])
      colnames(result1)[1:3] <- c("chr_merge","start_merge","end_merge")
      result1 <- result1%>%
        group_by(chr_merge,start_merge,end_merge) %>%
        mutate(distinct_samples = n_distinct(SAMPLE)) %>%
        mutate(merge_width=(max(END_B)-min(START_B))) %>%#重新算一下cluster的长度
        ungroup()

      result1 <- result1 %>%
        mutate(same_chr=ifelse(chr==chr_merge,"yes","no"))
      return(result1)}else{return(NULL)}
  }
}

#把癌基因的表格整理起来，再画个图；这些SV cluster和表达的关系在5-2里面去写

cl <- makeCluster(48)
clusterExport(cl,varlist = c("rheinbay_test_table1","ensembl_canonical_transcripts_bed4"))
list_cancergene_svcluster <- parLapply(cl,all_drivergenes_list, get_merge_candidate)
stopCluster(cl)

#去掉其中为NULL的元素
list_cancergene_svcluster <- Filter(Negate(is.null), list_cancergene_svcluster)
rheinbay_test_cancergene_svcluster <- do.call(rbind,list_cancergene_svcluster)
save(rheinbay_test_cancergene_svcluster,file="~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_cancergene_svcluster")
sessionInfo()



#绘制柱状图-Intrachromosome
#按照candidate统计一下
load("~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_cancergene_svcluster")
df <- rheinbay_test_cancergene_svcluster[,c(1:3,5,27,28,29)]
df <- unique(df) #一共是245个cancer gene-related cluster


df1 <- df %>%
  filter(distinct_samples>=10)%>% #1%
  mutate(n_per_l = (distinct_samples/merge_width*1000000 )) %>%
  arrange(desc(n_per_l))
df1_plot <- df1[1:10,]
df1_plot$gene_name <- factor(df1_plot$gene_name,levels = df1_plot$gene_name[10:1])
df1_plot$x <- paste0(df1_plot$gene_name,"(N=",df1_plot$distinct_samples,")") #设置x轴标签
df1_plot$pos <- paste0("Partner region:",df1_plot$chr_merge," ",
                       round(df1_plot$start_merge/1000000,1),"Mb",
                       "-",
                       round(df1_plot$end_merge/1000000,1),"Mb")#设置坐标标签
p5_0_1 <- ggplot(df1_plot,aes(x=gene_name,y=n_per_l)) +
  geom_bar(stat = "identity",fill="#820938")+
  geom_text(aes(label = pos[10:1]),hjust=-0.1,vjust = 0.3) +
  labs(x="",y="Number_of_samples/Mb")+
  theme_bw()+
  ylim(-5,120)+
  scale_x_discrete(
    labels = df1_plot$x[10:1],
  ) +
  coord_flip() +
  ggtitle("High-frequency Juxtaposition",
          subtitle = "(Breakpoints inside Transcript)")+
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.key.size = unit(3, "pt"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_text(size = 14, face = "bold"),  # 横坐标加粗并增大字体
    axis.title.y = element_text(size = 14, face = "bold"),   # 纵坐标加粗并增大字体
    axis.text.x =  element_text(size = 10,hjust = 1,face = "bold"),  # 横坐标字体加大加粗
    axis.text.y = element_text(size = 12, face = "bold"),
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 12, face = "bold")
  )

#绘制柱状图-Interchromosome
if(0){
df1 <- df %>%
  filter(same_chr=="no") %>%
  mutate(n_per_l = (distinct_samples/merge_width)*1000000 ) %>%
  arrange(desc(n_per_l))
#这里发现有好几个fusion发生的位置居然一模一样？
#EEF1A1-CLSPN 8个
#EEF1A1-LINC02516 10个 EEF1A1的这18个SV的起始位点居然都是chr6:73521228-73521229(bed)
#还有另外一个2个的
#高度怀疑这里可能是技术问题，但是PR,SR却又很高,mappablity也是好的？
#要看真假的话需要检查一下RNA-Seq的reads-更仔细的话要用RNA-Seq去看下fusion
#检查RNA-Seq的结果(用ALK作为阳性对照)
if(0){
  #EEF1A1 需要检查的区间是chr6:73489307-73525587 检查了几个这个位置基本都没reads，
  #有reads也不是soft-clipped或者方向有问题的reads，等会再检查下DNA reads，看下为什么是FP;
  #事实上看了DNA没有证据表明一定是FP，只是这个位置其实不在表达的转录本里面

  EEF1A1_Fusion_samples <- rheinbay_test_table1 %>%
    filter(CHROM_A=="chr6",START_A=="73521228") %>%
    select(SAMPLE)
  write.table(EEF1A1_Fusion_samples,
              col.names = F,
              file = "~/1000_noncoding/3.SV_analysis/2.analysis/tmp/EEF1A1_Fusion_sample.txt",
              quote = F,
              row.names = F)
  #ALK 需要检查的区间是 chr2:29192773-29921586 看了几个确实是有soft clipped reads
  coding_df <- read.delim("~/1000_noncoding/3.SV_analysis/1.resources/new_mut_fus_combined.txt")
  ALK_Fusion_samples <- coding_df %>%
    filter(Hugo_gene_name=="ALK",Variant_Classification=="Fusion") %>%
    select(Tumor_Sample_Barcode)
  write.table(ALK_Fusion_samples,
              col.names = F,
              file = "~/1000_noncoding/3.SV_analysis/2.analysis/tmp/ALK_Fusion_sample.txt",
              quote = F,
              row.names = F)
  }


df1_plot <- df1[1:10,]
df1_plot$x <- paste0(df1_plot$gene_name,"(N=",df1_plot$distinct_samples,")")
# 为B列添加重复次数信息
df1_plot <- df1_plot %>%
  group_by(x) %>%
  mutate(B = paste(x, "(", row_number(), ")", sep = "")) %>%
  ungroup()


df1_plot$B <- factor(df1_plot$B,levels = df1_plot$B)

p5_0_2  <- ggplot(df1_plot,aes(x=B,y=n_per_l)) +
  geom_bar(stat = "identity")+
  labs(x="",y="Number_of_samples/Mb")+
  theme_bw()+
  scale_fill_manual(values = c("Candidates" ="#CD3B42" ,
                               "Possible Candidates" = "#820938"))+
  scale_x_discrete(labels=df1_plot$x) +
  theme(
    legend.position = "none",
    legend.title = element_blank(),
    legend.key.size = unit(3, "pt"),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.title.x = element_text(size = 14, face = "bold"),  # 横坐标加粗并增大字体
    axis.title.y = element_text(size = 14, face = "bold"),   # 纵坐标加粗并增大字体
    axis.text.x =  element_text(size = 10,angle = 90,hjust = 1,face = "bold"),  # 横坐标字体加大加粗
    axis.text.y = element_text(size = 12, face = "bold")
  )

##先看一下找到的是不是ALK融合
if(0){
coding_df <- read.delim("~/1000_noncoding/3.SV_analysis/1.resources/new_mut_fus_combined.txt")
df <- rheinbay_test_cancergene_svcluster %>%
  mutate(Tumor_Sample_Barcode=SAMPLE,Hugo_Symbol=gene_name) %>%
  left_join(coding_df,by=c("Tumor_Sample_Barcode","Hugo_Symbol"))}
#20的这个cluster只有一个不是的，但是我看cluster的length其实没有2M这么长，已修正
##然后把cluster坐标标在图里面，不方便的话把图转过来-done
##最后加一个标题-done
}

#####计算SV对expression的影响
library(doParallel)

##loading files
load("~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_cancergene_svcluster")
load("~/1000_noncoding/3.SV_analysis/2.analysis/expr_all.Rdata")
expr <- expr_allsamples
load("~/1000_noncoding/3.SV_analysis/2.analysis/config_986.Rdata")
load("~/1000_noncoding/3.SV_analysis/2.analysis/genes_expr_less50Tumor.Rdata")
if(1){
  cnv_filepath <- "/home/data/t190513/1000_noncoding/3.SV_analysis/1.resources/all_data_by_genes.txt"
  cnv <- fread(cnv_filepath,data.table = F)
  cnv_1 <- cnv
  rownames(cnv_1) <- cnv_1$`Gene Symbol`
  cnv_1[,1:3] <- NULL
  #只留下config有的样本Tumor的列
  pattern <- paste(config_986,collapse = "|")
  cnv_1 <- cnv_1[,grepl(pattern,colnames(cnv_1))]
}

##计算差异表达p值
#计算raw_foldchange,raw_p,cnnormal_foldchange,cnnormal_p
expr_rownames <- rownames(expr)
expr_hugosymbol <- sapply(expr_rownames,function(x) strsplit(x,"\\|")[[1]][2])
#Func1 输入gene和df,返回raw_p和raw_foldchange
p_expr <- function(chr,start,end,gene,df,expr_rownames,expr_hugosymbol){
  library(dplyr)
  mutated_samples <- df %>%
    filter(gene_name==gene,chr_merge==chr,start_merge==start,end_merge==end) %>%
    select(SAMPLE)
  mutated_samples <- unique(mutated_samples$SAMPLE)
  mutated_indices <- which(names(expr) %in% mutated_samples)
  d_f <- data.frame()
  #如果该基因是ENSG开头,与在rownames里即可
  if(grepl("^ENSG",gene)){
    d_f <- expr[grepl(gene,expr_rownames),]
  }else{ #如果是Hugo_Symbol与Hugo_Symbol比对，需完全匹配
    d_f <- expr[expr_hugosymbol==gene,]
  }
  #如果能匹配上
  if(nrow(d_f)==1 & sum(mutated_indices) != 0){
    # 将表达量分组
    #原本的mutated samples是以，相连接的一些值，弄成一个向量
    group_mutated <- as.numeric(d_f[1,mutated_indices])
    group_unmutated <- as.numeric(d_f[1,-mutated_indices])
    #进行检验
    wilcox_test_result <- wilcox.test(group_mutated, group_unmutated)
    p <- wilcox_test_result$p.value
    #结果写入result
    log2_fc <- log2(median(as.numeric(group_mutated))/median(as.numeric(group_unmutated)))
    result <- paste(p,log2_fc,sep = ":")
    return(result)
  }else{return(NA)
  }
}
#Func2 输入id，靶基因，和ems数据框，得到突变样本和非突变样本的值和检验p值和log2 FC,和Func1不同的是
#假设检验仅在cn normal的样本中进行(1-22 cn=2)
p_expr_cnnormal <- function(chr,start,end,target_gene,df,expr_rownames,expr_hugosymbol){
  library(dplyr)
  mutated_samples <- df %>%
    filter(gene_name==target_gene,chr_merge==chr,start_merge==start,end_merge==end) %>%
    select(SAMPLE)
  mutated_samples <- unique(mutated_samples$SAMPLE)
  cn_samples <- names(cnv_1)[cnv_1[target_gene, ] > log2(1/2) & cnv_1[target_gene, ] < log2(2)]
  #cn_samples <- names(cnv_1)[cnv_1[target_gene, ] %in% c(-1,0,1)]
  cn_mutated_samples <- intersect(cn_samples,mutated_samples)
  cn_unmutated_samples <- setdiff(cn_samples,mutated_samples)
  mutated_indices <- which(names(expr) %in% cn_mutated_samples)
  unmutated_indices <- which(names(expr) %in% cn_unmutated_samples)
  d_f <- data.frame()
  #如果该基因是ENSG开头,与在rownames里即可
  if(grepl("^ENSG",target_gene)){
    d_f <- expr[grepl(target_gene,expr_rownames),]
  }else{ #如果是Hugo_Symbol与Hugo_Symbol比对，需完全匹配
    d_f <- expr[expr_hugosymbol==target_gene,]
  }
  #如果能匹配上且samples不为0
  if(nrow(d_f)==1 & sum(mutated_indices) != 0){
    # 将表达量分组
    #原本的mutated samples是以，相连接的一些值，弄成一个向量
    group_mutated <- as.numeric(d_f[1,mutated_indices])
    group_unmutated <- as.numeric(d_f[1,unmutated_indices])
    #进行检验
    wilcox_test_result <- wilcox.test(group_mutated, group_unmutated)
    p <- wilcox_test_result$p.value
    #结果写入result
    log2_fc <- log2(median(as.numeric(group_mutated))/median(as.numeric(group_unmutated)))
    result <- paste(p,log2_fc,sep = ":")
    return(result)
  }else{return(NA)
  }
}

df <- rheinbay_test_cancergene_svcluster[,c(1:5,27,28,29)]
df <- unique(df) #一共是245个cancer gene-related cluster

#计算raw_p和raw_fc
if(1){
  results <- rep(NA,nrow(df))
  cl <- makeCluster(48)
  # 注册并行后端
  registerDoParallel(cl)
  # 并行执行 for 循环
  results <- foreach(i = 1:nrow(df), .combine = c) %dopar% {
    library(dplyr)
    p_expr(df$chr_merge[i],df$start_merge[i],df$end_merge[i],
           df$gene_name[i],rheinbay_test_cancergene_svcluster[,-c(6,7,8)], expr_rownames, expr_hugosymbol)
  }
  # 停止并行计算
  stopCluster(cl)
  df$p_expr <- results
  df <- df %>%
    separate(p_expr,into=c("raw_expr_p","raw_expr_log2FC"),sep = ":")
}
#计算cnnormal_p和cnnormal_fc
if(1){
  results <- rep(NA,nrow(df))
  cl <- makeCluster(48)
  # 注册并行后端
  registerDoParallel(cl)
  # 并行执行 for 循环
  results <- foreach(i = 1:nrow(df), .combine = c) %dopar% {
    library(dplyr)
    p_expr_cnnormal(df$chr_merge[i],df$start_merge[i],df$end_merge[i],
                    df$gene_name[i],rheinbay_test_cancergene_svcluster[,-c(6,7,8)], expr_rownames, expr_hugosymbol)
  }
  # 停止并行计算
  stopCluster(cl)
  df$p_expr_cnnormal <- results
  df <- df %>%
    separate(p_expr_cnnormal,into=c("cnnormal_expr_p","cnnormal_expr_log2FC"),sep = ":")
}

df <- df %>%
  mutate(expr_over_50=ifelse(gene_name %in% gene_expr_less50,TRUE,FALSE)) %>% #其实gene_expr_less50是over50的基因集，变量名写反了不过不影响
  mutate(cancer_gene=ifelse(gene_name %in% all_drivergenes_list,TRUE,FALSE))
rheinbay_test_cancergene_svcluster_expr <- df

save(rheinbay_test_cancergene_svcluster_expr,
     file="~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_cancergene_svcluster_expr.Rdata")

########绘制火山图
load("~/1000_noncoding/3.SV_analysis/2.analysis/5-0.rheinbay_test_cancergene_svcluster_expr.Rdata")
#得到癌基因list
if(1){
  cancer_gene_737_filepath <- "/home/data/t190513/1000_noncoding/activedriverwgs/737 cancer genes by pcawg.csv"
  lung_drivers_df_filepath <- "/home/data/t190513/1000_noncoding/activedriverwgs/20220203_lung_drivers.csv"
  cosmic_census_cancer_gene_filepath <- "/home/data/t190513/1000_noncoding/activedriverwgs/Cancer Gene Census v100.tsv"
  oncokb_drivergenes_list_filepath <- "/home/data/t190513/1000_noncoding/activedriverwgs/oncokb_cancerGeneList_2024_10_24.tsv"
  OncoKB_driver <- fread(oncokb_drivergenes_list_filepath)
  CGC_driver <- fread(cosmic_census_cancer_gene_filepath)
  PCAWG_driver <- fread(cancer_gene_737_filepath)
  names(PCAWG_driver) <- "Gene_Symbol"
  lung_driver <- fread(lung_drivers_df_filepath)
  all_drivergenes_list <- union(OncoKB_driver$`Hugo Symbol`,CGC_driver$`Gene Symbol`)
  all_drivergenes_list  <- union(all_drivergenes_list,PCAWG_driver$Gene_Symbol)
  all_drivergenes_list <- union(all_drivergenes_list,lung_driver$Gene_Symbol)
  all_drivergenes_df <- data.frame(gene=all_drivergenes_list) %>%
    mutate(`Gene Symbol`=gene,`Hugo Symbol`=gene) %>%
    left_join(OncoKB_driver,by=c("Hugo Symbol")) %>%
    left_join(CGC_driver,by=c("Gene Symbol")) %>%
    select(gene,`Is Oncogene`,`Is Tumor Suppressor Gene`,`Role in Cancer`)

}

##准备绘图用的数据框,只看癌基因
## 筛选阈值
lfc=1
pval=0.05
df <- rheinbay_test_cancergene_svcluster_expr %>%
  #得到基因是不是癌基因还是抑癌基因，用于后面标记
  mutate(gene=gene_name) %>%
  left_join(all_drivergenes_df,by=c("gene")) %>%
  select(-gene) %>%
  #去掉<50肿瘤中表达的基因
  filter(expr_over_50==T) %>%
  #去掉cnnormal_expr_p为NA的基因
  filter(!is.na(cnnormal_expr_p)) %>%
  #得到绘图用的几项
  mutate(gene_id=gene_name,
         log2FoldChange=as.numeric(cnnormal_expr_log2FC),
         p=as.numeric(cnnormal_expr_p)) %>%
  mutate(color=case_when(
    abs(log2FoldChange)>lfc & p>pval ~ "grey",
    abs(log2FoldChange)<lfc & p<pval ~ "grey",
    #abs(log2FoldChange)>lfc & p<pval ~ pal_nejm("default", alpha = 0.4)(8)[1],
    abs(log2FoldChange)>lfc & p<pval ~ "#ED8172",
    abs(log2FoldChange)<lfc & p>pval ~ "grey"
  ),
  plot_label=case_when(
    abs(log2FoldChange)>lfc & p<pval & log2FoldChange > 0 & `Is Oncogene`=="Yes"~ gene_id,
    abs(log2FoldChange)>lfc & p<pval & log2FoldChange < 0 & `Is Tumor Suppressor Gene`=="Yes" ~ gene_id
  )
  ) %>%
  select(gene_id,log2FoldChange,p,
         `Is Oncogene`,`Is Tumor Suppressor Gene`,distinct_samples,
         color,plot_label)
p5_0_2 <- ggplot(df,aes(log2FoldChange, -log10(p), fill=color,label=plot_label)) +
  geom_point(alpha=1,size=4,pch=21) +
  #geom_text(hjust=-0.3, vjust=0) +
  scale_fill_identity() +
  labs(x=expression(Log[2]~fold~change~(CN~adjusted)), y=expression(-~Log[10]~p~value~(CN~adjusted))) +
  geom_vline(xintercept=c(-lfc,lfc), linetype=2) + geom_hline(yintercept=-log10(pval), linetype=5) +
  ggrepel::geom_label_repel(alpha=1,family="sans",color="black",fill="white",face="italicize",max.overlaps = Inf) +
  #scale_y_log10() +
  xlim(-5,5) +
  theme_bw() +
  theme(axis.title = element_text(size=16),
        text = element_text(family="sans"))


#ggsave("./Fig/volcano.pdf",width=6,height=6)

```
                                                    (Result)
The output from FASTQC and multiqc look good!  Proceeding to differential expression analysis of unicorn horn between activated and unactivated samples.
